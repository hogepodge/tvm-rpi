#!python3 ./infer.py

from time import sleep
from picamera import PiCamera
import numpy as np
import tarfile
import tempfile
import os
import timeit
import tvm
from tvm.contrib import graph_runtime as runtime
from tvm.contrib.download import download_testdata
from scipy.special import softmax

# Download the and load labels for the model to output the inferrence
# human-readable form
labels_url = "https://s3.amazonaws.com/onnx-model-zoo/synset.txt"
labels_path = download_testdata(labels_url, "synset.txt", module="data")

with open(labels_path, "r") as f:
    labels = [l.rstrip() for l in f]


# Open the library module that was generated by tvmc. This requires unzipping
# the file to a new location, then loading the runtime graph, the parameters,
# and the generated library code
with tempfile.TemporaryDirectory() as tmp_dir:
    # open the library
    t = tarfile.open("resnet50-v2-7.tvm")
    #t = tarfile.open("resnet50-v2-7.tuned200.tvm")
    t.extractall(tmp_dir)

    # load the runtime graph
    graph = open(os.path.join(tmp_dir, "mod.json")).read()

    # load the model parameters
    params = bytearray(open(os.path.join(tmp_dir, "mod.params"), "rb").read())

    # load the compiled library
    lib = tvm.runtime.load_module(os.path.join(tmp_dir, "mod.so"))

    # create the runtime module from the runtime graph and library, targeting
    # the cpu
    module = runtime.create(graph, lib, tvm.context("cpu"))

    # load the model parameters into the module
    module.load_params(params)

    # initialize the camera, since we're down-scaling we'll use a low
    # resolution mode
    camera = PiCamera(sensor_mode=4)

    # set the resolution to the image size expected by ResNet
    camera.resolution = (224,224)
    camera.annotate_text_size = 12 

    # This is optional, we launch a preview so we can see the image, set some
    # exposure parameters, and hold the image on the screen the screen for the
    # specified number of seconds.

    def infer():
        camera.start_preview()
        camera.exposure_mode='auto'
        camera.iso=800
        annotate_text = [camera.annotate_text]
        #sleep(5)

        # Prepare a numpy buffer to capture the image in
        inage_data = np.empty((224, 224, 3), dtype=np.int8)
        
        # The overlay becomes part of the image, so clear it
        # before capturing
        camera.annotate_text = ""

        # Capture the image in rgb format
        camera.capture(inage_data, "rgb")

        # Write the previous prediction over the image while inference is run.
        camera.annotate_text = annotate_text[0]

        # Convert the image to floating point values
        inage_data=inage_data.astype("float32")

        # Reorder the image into the format expected by ResNet
        # Also apply normalization expected by ResNet
        inage_data= np.transpose(inage_data, (2, 0, 1))
        imagenet_mean = np.array([0.485, 0.456, 0.406])
        imagenet_stddev = np.array([0.229, 0.224, 0.225])

        # Initialize the normalization matrix
        norm_img_data = np.zeros(inage_data.shape).astype("float32")

        # Compute the normalization
        for i in range(inage_data.shape[0]):
            norm_img_data[i, :, :] = (inage_data[i, :, :] / 255 - imagenet_mean[i]) / imagenet_stddev[i]

        # Add one more dimension in the input matrix, as expected by ResNet
        inage_data = np.expand_dims(norm_img_data, axis=0)

        # Set the input and run the model
        module.set_input("data", inage_data)
        module.run()
        inage_data_shape = (1, 1000)

        # Get the output tensor
        tvm_inage_data = module.get_output(0, tvm.nd.empty(inage_data_shape)).asnumpy()

        # Compute the confidence of each classification, and sort
        scores = softmax(tvm_inage_data)
        scores = np.squeeze(scores)
        ranks = np.argsort(scores)[::-1]

        # Output the five most likely labels
        Annotate_text = []
        for rank in ranks[0:5]:
            annotate_text.append("%s probability=%f" % (labels[rank], scores[rank]))
            print("%s probability=%f" % (labels[rank], scores[rank]))
        print("---")

    timer = timeit.Timer(infer)
    while(True):
        number = 10
        print("Average time for %s runs: %s" % (number, timer.timeit(number=number)/number))

